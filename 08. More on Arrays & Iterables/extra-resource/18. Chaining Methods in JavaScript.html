<p>With all these useful array methods you learned about, it's important to understand how you can combine them. Let's take <code>map()</code>&nbsp;and <code>reduce()</code>&nbsp;as an example:</p><pre class="prettyprint linenums">const originalArray =&nbsp;[{price:&nbsp;10.99}, {price:&nbsp;5.99}, {price:&nbsp;29.99}];
const transformedArray =&nbsp;originalArray.map(obj =&gt;&nbsp;obj.price); //&nbsp;produces [10.99, 5.99, 29.99]
const sum =&nbsp;transformedArray.reduce((sumVal, curVal) =&gt;&nbsp;sumVal + curVal, 0);&nbsp;// =&gt;&nbsp;46.97</pre><p>Of course, you could skip the map step and just add the extraction logic to <code>reduce()</code>:</p><pre class="prettyprint linenums">const originalArray =&nbsp;[{price:&nbsp;10.99}, {price:&nbsp;5.99}, {price:&nbsp;29.99}];
const sum =&nbsp;originalArray.reduce((sumVal, curVal) =&gt;&nbsp;sumVal + curVal.price, 0);&nbsp;// =&gt;&nbsp;46.97</pre><p>But let's say you have a more complex extraction logic and hence want to split this into multiple method calls. Or you have a re-usable map function which you want to be able to use in different places of your app. Then you can still write the initial example in a more concise way if you <strong>leverage method chaining</strong>:</p><pre class="prettyprint linenums">const originalArray =&nbsp;[{price:&nbsp;10.99}, {price:&nbsp;5.99}, {price:&nbsp;29.99}];
const sum =&nbsp;originalArray.map(obj =&gt;&nbsp;obj.price)
    .reduce((sumVal, curVal) =&gt;&nbsp;sumVal + curVal, 0);&nbsp;// =&gt;&nbsp;46.97</pre><p>We call <code>.reduce()</code> directly on the result of <code>map()</code>&nbsp;(which produces an array, that's why this is possible). Hence we can avoid storing the mapped array in a separate constant or variable that we might not need in any other place.</p>